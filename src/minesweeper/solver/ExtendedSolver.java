package minesweeper.solver;

import minesweeper.gamestate.GameStateModel;
import minesweeper.gamestate.MoveMethod;
import minesweeper.solver.coach.CoachModel;
import minesweeper.solver.coach.CoachSilent;
import minesweeper.solver.constructs.CandidateLocation;
import minesweeper.solver.constructs.WitnessData;
import minesweeper.solver.iterator.Iterator;
import minesweeper.solver.iterator.SequentialIterator;
import minesweeper.solver.settings.SolverSettings;
import minesweeper.solver.utility.Binomial;
import minesweeper.solver.utility.Logger;
import minesweeper.structure.Action;
import minesweeper.structure.Area;
import minesweeper.structure.Location;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ExtendedSolver extends Solver {
    // used to hold valid moves which are about to be passed out of the solver
    public static class FinalMoves {

        public Action[] result = new Action[0];
        int suppressedFlags = 0;    // number of place flag moves suppressed because of playing Flag Free
        boolean moveFound = false; // this is set to true if a move is found, even if it is suppressed

        public FinalMoves(Action...actions) {
            result = actions;
            moveFound = (actions.length > 0);
        }

    }

    private class LoopCheck implements Runnable {

        private boolean finished = false;

        @Override
        public void run() {

            int countDown = 100;

            while (countDown > 0 && !finished) {
                try {
                    Thread.sleep(20);
                } catch (InterruptedException e) {
                }
                countDown--;
            }

            if (!finished) {
                String gameKey = myGame.showGameKey();
                System.out.println(gameKey + " might be looping");
            }

        }

        public void finishedOkay() {
            finished = true;
        }

    }

    final static BigDecimal OFF_EDGE_TOLERENCE = new BigDecimal("0.95");  // was 0.98 --- consider off edge tiles which if they are above the threshold of the best on edge tile
    final static boolean PRUNE_BF_ANALYSIS = true;
    final static boolean CONSIDER_HIGH_DENSITY_STRATEGY = false;

    public final static BigDecimal PROGRESS_VALUE = new BigDecimal("0.20");  // how much 100% Progress is worth as a proportion of Safety
    final static BigDecimal PROB_ENGINE_HARD_TOLERENCE = new BigDecimal("0.90"); // consider tiles on the edge with a threshold of this from the best value
    final static BigDecimal PROGRESS_MULTIPLIER = BigDecimal.ONE.add(PROGRESS_VALUE);
    //final static BigDecimal OFF_EDGE_TOLERENCE = BigDecimal.ONE.subtract(PROGRESS_VALUE); // consider off edge tiles which if they are above the threshold of the best on edge tile

    final static BigDecimal PROB_ENGINE_TOLERENCE = BigDecimal.ONE.subtract(PROGRESS_VALUE).max(PROB_ENGINE_HARD_TOLERENCE);
    //final static BigDecimal PROB_ENGINE_TOLERENCE = new BigDecimal("0.85");  // for experimental tiebreak

    // won't play the book opening on start if false
    //protected final static boolean PLAY_OPENING = true;

    /**
     * If the number of iterations is less than this then process sequential else go parallel
     */
    final static BigInteger PARALLEL_MINIMUM = new BigInteger("10000");

    final static int CORES = Runtime.getRuntime().availableProcessors();


    // a binomial coefficient generator which allows up to (choose n from 1000000) and builds a cache of everything up to (choose n from 100)
    static Binomial binomialEngine = new Binomial(1000000, 500);


    // the class that knows the real board layout, which squares have been revealed and where the flags are
    private final GameStateModel myGame;

    // a class which can be used to display the summary information generated by the solver
    private final CoachModel coachDisplay;

    // a class which holds the solves current view of the board
    private final BoardState boardState;
    private ProbabilityEngineModel pe;
    private BruteForce bf;

    private BruteForceAnalysisModel bruteForceAnalysis;
    private LocationEvaluator evaluateLocations;

    private BigDecimal offEdgeProb;

    private List<Location> bfdaStartLocations = null;

    private List<Location> allWitnesses;
    private Area allWitnessedSquares;
    private Area deadLocations;


    // work areas
    private boolean[] workRestNotFlags;
    private boolean[] workRestNotClear;


    private Location overriddenStartLocation;

    private final boolean interactive;

    private FinalMoves answer;

    // used to indicate that the solver shouldn't bother placing flags on the board
    // this is considered expert tactics because it reduces the number of mouse actions.
    private boolean flagFree = false;

    // playing chords will make the solver run slower, but should result in less moves
    // it is suggested to play chords if playing an external boarding using mouse controller and you wish to look impressive
    private boolean playChords = false;

    // Shows the best tree in sysout from Brute Force Deep analysis
    private boolean showProbabilityTree = false;

    // won't play the book opening on start if false
    private boolean playOpening = true;

    // when set the solver will gather detailed information about the possible values each tile can have
    // intended for use with the Minesweeper Explorer. Can have significant performance impact.
    //private boolean gatherDetailedInformation = true;

    /**
     * Start the solver without a coach display
     * @param myGame
     * @param preferences
     * @param interactive
     */
    public ExtendedSolver(GameStateModel myGame, SolverSettings preferences, boolean interactive) {
        super(myGame, preferences, interactive);
        this.coachDisplay = new CoachSilent();
        this.myGame = myGame;
        this.interactive = interactive;

        this.overriddenStartLocation = preferences.getStartLocation();

        this.boardState = new BoardState(this);
        boardState.process();

        logger.log(Logger.Level.INFO, "Running with %d Cores", CORES);
        logger.log(Logger.Level.INFO, "Max memory available to JVM %d", Runtime.getRuntime().maxMemory());
        logger.log(Logger.Level.INFO, "Free Memory available to JVM %d", Runtime.getRuntime().freeMemory());
        logger.log(Logger.Level.INFO, "Solving game %s", myGame.showGameKey());

        List<Location> witnesses = new ArrayList<>(500);
        for (int x=0; x < myGame.getWidth(); x++) {
            for (int y=0; y < myGame.getHeight(); y++) {
                Location l = new Location(x,y);
                if (myGame.query(l) != GameStateModel.FLAG && myGame.query(l) != GameStateModel.HIDDEN) {
                    witnesses.add(l);
                }
            }
        }
        logger.log(Logger.Level.DEBUG, "Found %d witnesses already in the game", witnesses.size());
    }

    @Override
    public void start() {

        LoopCheck check = new LoopCheck();

        Thread checkThread  = new Thread(check);
        checkThread.start();

        int loopSafe = 0;

        answer = newProcess();
        while (answer.moveFound && answer.result.length == 0) {
            if (loopSafe++ >= 5) {
                this.logger.log(Logger.Level.WARN, "LOOPSAFE check!! - exiting the processing after %d iterations", loopSafe);
                break;
            }
            logger.log(Logger.Level.DEBUG, "There are no moves provided ( %d have been supressed) - rerunning the solver", answer.suppressedFlags );
            answer = newProcess();
        }

        check.finishedOkay();

    }

    @Override
    public void requestStop() {
    }

    @Override
    public Action[] getResult() {
        return answer.result;
    }
    // end of Asynchronous methods

    public FinalMoves newProcess() {
        FinalMoves fm = doNewProcess();

        if (fm.result.length > 0) {
            newLine("---------- Recommended Move ----------");
            newLine(fm.result[0].toString());
            newLine("----------  Analysis Ended -----------");
        }

        int testMoveBalance = boardState.getTestMoveBalance();
        if (testMoveBalance != 0) {
            this.logger.log(Logger.Level.ERROR, "Test moves are not being set and reset in pairs!! Balance = %d", testMoveBalance);

        }

        return fm;
    }

    protected FinalMoves doNewProcess() {

        this.logger.log(Logger.Level.INFO, "--- Starting Analysis ---");

        Action[] result = null;

        FinalMoves fm = new FinalMoves();

        long time1 = System.currentTimeMillis();

        coachDisplay.clearScreen();
        pe = null;
        bf = null;
        evaluateLocations = null;
        deadLocations = null;

        if (myGame.getGameState() == GameStateModel.LOST) {
            topLine("The game has been lost, so no further analysis is possible");
            if (myGame.supports3BV()) {
                newLine("3BV value " + myGame.get3BV());
                newLine("Action Count " + myGame.getActionCount());
            }
            return fm;
        }

        if (myGame.getGameState() == GameStateModel.WON) {
            topLine("The game has been won, so no further analysis is required");
            if (myGame.supports3BV()) {
                newLine("3BV value " + myGame.get3BV());
                newLine("Action Count " + myGame.getActionCount());
                double eff = ((10000 * myGame.get3BV()) / myGame.getActionCount()) / 100d;
                newLine("Efficiency is " + eff + "%");
            }
            return fm;
        }

        // query the game State object to get the current board position
        boardState.process();

        // being asked to start the game
        if (myGame.getGameState() == GameStateModel.NOT_STARTED && playOpening) {

            if (myGame.safeOpening()) {
                offEdgeProb = BigDecimal.ONE;
            } else {
                offEdgeProb = BigDecimal.ONE.subtract(BigDecimal.valueOf(myGame.getMinesLeft()).divide(BigDecimal.valueOf(myGame.getHidden()), Solver.DP, RoundingMode.HALF_UP));
            }

            fm = guess(null);

            newLine("This is the first move");
            newLine("Note: if you aren't accepting guesses nothing will happen!");
            newLine("---------- Recommended Move ----------");
            newLine(fm.result[0].toString());
            newLine("----------  Analysis Ended -----------");

            return fm;
        }

        // are we walking down a brute force deep analysis tree?
        if (bruteForceAnalysis != null) {
            Location expectedMove = bruteForceAnalysis.getExpectedMove();
            if (bruteForceAnalysis.isShallow() || expectedMove == null) {  // if the analysis was shallow then don't rely on it
                bruteForceAnalysis = null;
            } else {
                if (expectedMove != null && !boardState.isRevealed(expectedMove)) {  // we haven't played the recommended move - so the analysis is probably useless
                    this.logger.log(Logger.Level.INFO, "The expected Brute Force Analysis move %s wasn't played", expectedMove );
                    bruteForceAnalysis = null;
                } else {
                    if (myGame.query(expectedMove) != 0) {
                        Action move = bruteForceAnalysis.getNextMove(boardState);
                        if (move != null) {
                            this.logger.log(Logger.Level.INFO, "Brute Force Deep Analysis move is %s", move);
                            newLine("-------- Brute Force Deep Analysis Tree --------");
                            newLine(move.toString());
                            newLine("--------  Brute Force Deep Analysis Tree---------");
                            return new FinalMoves(move);
                        }
                    } else {
                        this.logger.log(Logger.Level.INFO, "After a zero the board can be in an unexpected state, so cancelling Brute Force Analysis moves");
                        bruteForceAnalysis = null;
                    }

                }
            }
        }

        int unrevealed = boardState.getTotalUnrevealedCount();

        allWitnesses = boardState.getAllLivingWitnesses();
        allWitnessedSquares = boardState.getUnrevealedArea(allWitnesses);


        newLine("----------- Game Situation -----------");
        newLine("There are " + allWitnesses.size() + " witness(es)");
        newLine("There are " + allWitnessedSquares.size() + " square(s) witnessed, out of " + unrevealed);

        if (unrevealed == 0) {
            newLine("Nothing to analyse!");
            //return fm;
        }

        // are the flags in the correct place?
        if (coachDisplay.analyseFlags() && boardState.getTotalFlagCount() > 0) {
            //newLine("----------  Flag Analysis -----------");
            if (boardState.getConfirmedFlagCount() == boardState.getTotalFlagCount()) {
                coachDisplay.setOkay();
                newLine("All " + boardState.getTotalFlagCount() + " flags have been confirmed as correct");
            } else {
                newLine((boardState.getTotalFlagCount() - boardState.getConfirmedFlagCount()) + " flags can not be confirmed as correct");
                if (boardState.validateData()) {
                    coachDisplay.setWarn();
                } else {
                    newLine("At least 1 flag is definitely wrong!");
                    coachDisplay.setError();
                }
            }
        } else {
            coachDisplay.setOkay();
        }

        // Build a web of all the witnesses still useful and all the un-revealed tiles adjacent to them
        WitnessWeb wholeEdge = new WitnessWeb(boardState, allWitnesses, allWitnessedSquares.getLocations());

        int obvious = findTrivialActions(wholeEdge.getPrunedWitnesses());

        long time2 = System.currentTimeMillis();

        int lessObvious = findLocalActions(wholeEdge.getPrunedWitnesses());

        long time3 = System.currentTimeMillis();

        // output some text describing the results

        int displayObvious = obvious + boardState.getUnplayedMoves(MoveMethod.TRIVIAL);
        int displayLessObvious = lessObvious + boardState.getUnplayedMoves(MoveMethod.LOCAL);

        newLine("----------- Basic Analysis -----------");
        newLine("There are " + displayObvious + " trivial moves found in " + (time2 - time1) + " milliseconds");
        newLine("There are " + displayLessObvious + " locally certain moves found in " + (time3 - time2) + " milliseconds");

        this.logger.log(Logger.Level.INFO, "There are %d trivial / locally discoverable certain moves", (displayObvious + displayLessObvious));

        if (playChords) {
            EfficiencyHelper eff = new EfficiencyHelper(boardState, wholeEdge, boardState.getActions());
            fm = new FinalMoves(eff.process().toArray(new Action[0]));
        } else {
            fm = new FinalMoves(boardState.getActions().toArray(new Action[0]));
        }


        //fm = new FinalMoves(boardState.getActionsWithChords().toArray(new Action[0]));
        if (obvious + lessObvious > 0) {  // in flag free mode we can find moves which we don't play
            fm.moveFound = true;
        }
        result = fm.result;

        /*
        // look for a 50-50 guess which can't be avoided
        FinalMoves findFifty = null;
        if (obvious + lessObvious == 0 && !fm.moveFound && preferences.do5050Check()) {
        	findFifty = findFiftyFifty(wholeEdge);
        	if (findFifty.moveFound) {
        		newLine("--------- Unavoidable Guess ---------");
        		newLine("An unavoidable guess has been found - playing now to save time");
        		fm = findFifty;
        		display("***** Fifty Fifty " + myGame.showGameKey() +  ": " + fm.result[0].asString() );
        	}
        }
		*/

        int minesLeft = myGame.getMines() - boardState.getConfirmedFlagCount();

        if (interactive) {  // can be expensive to do this, so only if we are actually going to display it
            BigInteger comb = combination(minesLeft, unrevealed);
            this.logger.log(Logger.Level.INFO, "Combinations: choose %d from %d gives %d", minesLeft, unrevealed, comb);
        }

        // leave at this point if we have got something to do
        if (fm.moveFound) {
            return fm;
        }

        // If no trivial, local, or unavoidable guess then use the probability engine


        // find (some) dead locations on the board - these can be ignored when looking for a good guess
        deadLocations = Area.EMPTY_AREA;

        this.logger.log(Logger.Level.INFO, "----- Starting probability engine -----");

        pe = new ProbabilityEngineFast(boardState, wholeEdge, unrevealed, minesLeft);
        pe.process();

        // get the new deadLocations with any found by the probability engine
        deadLocations = pe.getDeadLocations();

        offEdgeProb = pe.getOffEdgeProb();

        if (offEdgeProb.compareTo(BigDecimal.ONE) > 0) {
            this.logger.log(Logger.Level.ERROR, "Game %s has probability off edge of %f", myGame.showGameKey(), offEdgeProb);
        } else {
            this.logger.log(Logger.Level.INFO, "Probability off edge is %f", offEdgeProb);
        }

        // if all the locations are dead then just use any one (unless there is only one solution)
        if (deadLocations.size() == allWitnessedSquares.size() && deadLocations.size() != 0) {
            if (pe.getSolutionCount().compareTo(BigInteger.ONE) == 0) {
                this.logger.log(Logger.Level.INFO, "Only one solution left");
            } else {
                this.logger.log(Logger.Level.INFO, "All locations are dead");
            }

            //deadLocations = Area.EMPTY_AREA;

            // if there are no squares next to a witness then just guess
            if (allWitnessedSquares.getLocations().isEmpty()) {
                return guess(wholeEdge);
            }

            // otherwise pick one of the ones on the edge
            Location picked = getLowest(allWitnessedSquares.getLocations());

            CandidateLocation cl = new CandidateLocation(picked.x, picked.y, pe.getProbability(picked), 0, 0);
            Action a = cl.buildAction(MoveMethod.GUESS);
            // let the boardState decide what to do with this action
            boardState.setAction(a);

            result = boardState.getActions().toArray(new Action[0]);

            fm = new FinalMoves(result);
            return fm;
        }


        // fetch the best candidates from the edge.  If high density only get the best tiles
        List<CandidateLocation> bestCandidates;
        if (boardState.isHighDensity()) {
            bestCandidates = pe.getBestCandidates(BigDecimal.ONE, true);
            //} else if (preferences.isExperimentalScoring()) {
            //	bestCandidates = pe.getBestCandidates(BigDecimal.valueOf(0.8d), true);
        } else {
            bestCandidates = pe.getBestCandidates(PROB_ENGINE_TOLERENCE, true);
        }

        List<Location> allUnrevealedSquares = null;

        /*
    	//  evaluate positions
        if (preferences.getGuessMethod() == GuessMethod.SECONDARY_SAFETY_PROGRESS) {
        	evaluateLocations = new SecondarySafetyEvaluator(this, boardState, wholeEdge, pe);
        } else {
        	evaluateLocations = new ProgressEvaluator(this, boardState, wholeEdge, pe);
        }
        */

        BigDecimal offEdgeCutoff = pe.getBestOnEdgeProb().multiply(Solver.OFF_EDGE_TOLERENCE);

        this.logger.log(Logger.Level.INFO, "Off edge threshold is %f", offEdgeCutoff);

        // are clears off the edge within the permitted cut-off?
        boolean addOffEdgeOptions = (offEdgeProb.compareTo(offEdgeCutoff) > 0);

        this.logger.log(Logger.Level.INFO, "Probability Engine processing took %d milliseconds", pe.getDuration());
        this.logger.log(Logger.Level.INFO, "----- Probability engine finished -----");

        newLine("------ Probability Engine Analysis ------");
        newLine("There are " + pe.getIndependentGroups() + " independent edges on the board");
        newLine("Probability Engine processing took " + pe.getDuration() + " milliseconds");

        if (pe.getSolutionCount().bitLength() < 40) {
            newLine("There are " + pe.getSolutionCount() + " candidate solutions remaining");
        }

        boolean certainClearFound = pe.foundCertainty();

        // look for unavoidable 50/50
        FiftyFiftyHelper fiftyFiftyHelper = null;
        if (!pe.foundCertainty()) {
            if (preferences.isDo5050Check()) {
                fiftyFiftyHelper = new FiftyFiftyHelper(boardState, wholeEdge, deadLocations);
                Location findFifty = fiftyFiftyHelper.findUnavoidable5050(pe.getMines());

                if (findFifty != null) {
                    Action a = new Action(findFifty, Action.CLEAR, MoveMethod.UNAVOIDABLE_GUESS, "Fifty-Fifty",  pe.getProbability(findFifty));
                    fm = new FinalMoves(a);

                    newLine("--------- Unavoidable Guess ---------");
                    newLine("An unavoidable guess has been found - playing now to save time");
                    this.logger.log(Logger.Level.DEBUG, "Fifty/Fifty found in game %s : %s", myGame.showGameKey(), fm.result[0] );
                    return fm;
                }
            }
        }

        // if there are no certain moves then process any Isolated non-dead edges we have found
        if (!certainClearFound && !pe.getIsolatedEdges().isEmpty()) {
            this.logger.log(Logger.Level.INFO, "Processing an Isolated edge");
            newLine("--------- Isolated Area ---------");
            newLine("An isolated area has been found which can be processed separately");

            // get the smallest isolated area to solve
            BruteForce cruncher = null;
            for (BruteForce c: pe.getIsolatedEdges()) {
                if (cruncher == null || c.getTileCount() < cruncher.getTileCount()) {
                    cruncher = c;
                }
            }

            // determine all possible solutions
            cruncher.process();

            if (cruncher.hasRun()) {

                // determine best way to solver them
                BruteForceAnalysisModel bfa = cruncher.getBruteForceAnalysis();
                if (bfa != null) {
                    bfa.process();

                    // if after trying to process the data we can't complete then abandon it
                    if (!bfa.isComplete()) {
                        this.logger.log(Logger.Level.WARN, "%s Abandoned the Brute Force Analysis after %d steps", myGame.showGameKey(), bfa.getNodeCount() );
                        bfa = null;

                    } else { // otherwise try and get the best long term move

                        bruteForceAnalysis = bfa;  // by setting this we will walk the tree until completed in subsequent solver calls

                        newLine("Built probability tree from " + bruteForceAnalysis.getSolutionCount() + " solutions in " + bruteForceAnalysis.getNodeCount() + " steps");
                        Action move = bruteForceAnalysis.getNextMove(boardState);
                        if (move != null) {
                            this.logger.log(Logger.Level.INFO, "%s Brute Force Analysis: %s", myGame.showGameKey(), move);
                            //newLine("Brute Force Analysis move is " + move.asString());
                            fm = new FinalMoves(move);
                            return fm;
                        } else {
                            if (bruteForceAnalysis.allDead()) {
                                this.logger.log(Logger.Level.INFO, "All Brute Force Analysis moves are dead");

                                // otherwise pick one of the ones on the edge
                                Location picked = getLowest(bruteForceAnalysis.getDeadLocations().getLocations());

                                //Location anyLocWillDo = null;
                                //for (Location l: bruteForceAnalysis.getDeadLocations().getLocations()) {  // get the first location
                                //	anyLocWillDo = l;
                                //	break;
                                //}

                                fm = new FinalMoves(new Action(picked, Action.CLEAR, MoveMethod.GUESS, "", pe.getProbability(picked)));
                                return fm;
                            }
                            this.logger.log(Logger.Level.WARN, "Game %s Brute Force Analysis: no move found!", myGame.showGameKey());
                        }
                    }
                } else {
                    this.logger.log(Logger.Level.WARN, "Game %s Brute Force analysis class is null", myGame.showGameKey());
                }

            } else {
                this.logger.log(Logger.Level.WARN, "Game %s Brute Force did not run", myGame.showGameKey());
            }
        }

        // look for pseudo 50-50 guess which can't be avoided

        if (!certainClearFound) {
            if (preferences.isDo5050Check()) {
                Location findFifty = new FiftyFiftyHelper(boardState, wholeEdge, deadLocations).process();

                if (findFifty != null) {
                    Action a = new Action(findFifty, Action.CLEAR, MoveMethod.UNAVOIDABLE_GUESS, "Fifty-Fifty",  pe.getProbability(findFifty));
                    fm = new FinalMoves(a);

                    newLine("--------- Unavoidable Guess ---------");
                    newLine("An unavoidable guess has been found - playing now to save time");
                    this.logger.log(Logger.Level.DEBUG, "Fifty Fifty %s : %s", myGame.showGameKey(), fm.result[0]);
                    return fm;
                }
            }
        }

        if (bestCandidates.isEmpty()) {
            newLine("The probability engine found no candidate moves on the edge");
            newLine("Probability off the edge is " + Action.FORMAT_2DP.format(offEdgeProb.multiply(ONE_HUNDRED)) + "%");
        } else {
            newLine("The probability engine found " + bestCandidates.size() + " candidate moves on the edge");
        }

        BigDecimal safeDensity = BigDecimal.valueOf( (double) (unrevealed - minesLeft) / (double) unrevealed);
        this.logger.log(Logger.Level.INFO, "Safe density %f", safeDensity);
        BigDecimal safeDensity3 = new BigDecimal(pe.getSolutionCount()).multiply(safeDensity).multiply(safeDensity).multiply(safeDensity);
        this.logger.log(Logger.Level.INFO, "BFDA Solution value %f", safeDensity3);

        // do brute force if the number of candidate solutions is not greater than the allowable maximum
        //boolean doBruteForce = (pe.getSolutionCount().compareTo(BigInteger.valueOf(preferences.getBruteForceMaxSolutions())) <= 0);
        boolean doBruteForce = (pe.getSolutionCount().compareTo(BigInteger.valueOf(preferences.getBruteForceMaxSolutions())) <= 0)
                || (safeDensity3.compareTo(BigDecimal.valueOf(preferences.getBruteForceVariableSolutions())) <= 0);

        //boolean certainFlagFound = !pe.getMines().isEmpty();

        BruteForceAnalysisModel incompleteBFA = null;  // this is used to carry forward an analysis run which didn't complete

        // Probability engine says there are few enough candidate solutions to do a Brute force deep analysis - so lets try
        if (doBruteForce && !certainClearFound) {
            this.logger.log(Logger.Level.INFO, "----- Brute Force starting -----");
            newLine("----------- Brute Force Analysis -----------");

            allUnrevealedSquares = boardState.getAllUnrevealedSquares();

            WitnessWeb wholeBoard = new WitnessWeb(boardState, wholeEdge.getPrunedWitnesses(), allUnrevealedSquares);

            bf = new BruteForce(this, boardState, wholeBoard, minesLeft, preferences.getBruteForceMaxIterations(), pe.getSolutionCount().intValue(), "Game");

            bf.process();

            if (bf.hasRun()) {
                newLine("Found " + bf.getSolutionCount() + " candidate solutions from " + bf.getIterations() + " iterations");

                // Interpret the brute force data if we have some
                this.bruteForceAnalysis = bf.getBruteForceAnalysis();
                if (!bf.hasCertainClear() && bruteForceAnalysis != null) {  // if we haven't found some 100% clears and we can do a deeper analysis

                    bruteForceAnalysis.process();

                    // if all the locations are dead then just use any one
                    if (bruteForceAnalysis.allDead()) {
                        this.logger.log(Logger.Level.INFO, "Brute force deep analysis has detected that all locations are dead");
                        // if there are no squares next to a witness then just guess
                        if (allWitnessedSquares.getLocations().isEmpty()) {
                            return guess(wholeEdge);
                        }

                        // otherwise pick one of the ones on the edge
                        Location picked = null;
                        for (Location l: allWitnessedSquares.getLocations()) {
                            if (pe.getProbability(l).signum() != 0) { // pick a tile which isn't a mine
                                picked = l;
                                break;
                            }
                        }
                        CandidateLocation cl = new CandidateLocation(picked.x, picked.y, pe.getProbability(picked), 0, 0);
                        Action a = cl.buildAction(MoveMethod.GUESS);
                        // let the boardState decide what to do with this action
                        boardState.setAction(a);

                        result = boardState.getActions().toArray(new Action[0]);

                        fm = new FinalMoves(result);
                        return fm;
                    }


                    // if after trying to process the data we can't complete then abandon it
                    if (!bruteForceAnalysis.isComplete()) {
                        this.logger.log(Logger.Level.WARN, "Game %s Abandoned the Brute Force Analysis after %d steps, %d of %d moves analysed",
                                myGame.showGameKey(), bruteForceAnalysis.getNodeCount(),  bruteForceAnalysis.getMovesProcessed(),  bruteForceAnalysis.getMovesToProcess());
                        incompleteBFA = bruteForceAnalysis;  // remember the incomplete analysis
                        bruteForceAnalysis = null;

                    } else { // otherwise try and get the best long term move

                        deadLocations = bruteForceAnalysis.getDeadLocations();

                        newLine("Built probability tree from " + bruteForceAnalysis.getSolutionCount() + " solutions in " + bruteForceAnalysis.getNodeCount() + " steps");
                        Action move = bruteForceAnalysis.getNextMove(boardState);
                        if (move != null) {
                            this.logger.log(Logger.Level.DEBUG, "Brute Force Analysis move: %s", move);
                            fm = new FinalMoves(move);
                        } else {
                            this.logger.log(Logger.Level.WARN, "Game %s Brute Force Analysis: no move found!", myGame.showGameKey());
                        }
                    }
                }

                // if we didn't find a BFDA move (too many solutions or too many nodes searched)
                if (!fm.moveFound) {

                    if (bestCandidates.isEmpty()) {
                        newLine("Brute Force didn't find any moves...?");
                    } else if (bestCandidates.get(0).getProbability().compareTo(BigDecimal.ONE) == 0) {
                        newLine("There are " + bestCandidates.size() + " certain moves");
                    } else {
                        newLine("There are no certain moves, so use the best guess");
                    }
                }

            } else {
                newLine("Brute Force rejected - too many iterations to analyse");
            }
            this.logger.log(Logger.Level.INFO, "----- Brute Force finished -----");
        }

        //  evaluate positions
        if (preferences.getGuessMethod() == SolverSettings.GuessMethod.SECONDARY_SAFETY_PROGRESS) {
            evaluateLocations = new SecondarySafetyEvaluator(this, boardState, wholeEdge, pe, incompleteBFA, fiftyFiftyHelper);
        } else {
            evaluateLocations = new ProgressEvaluator(this, boardState, wholeEdge, pe);
        }

        // if we have few enough solutions do an adversarial rollout
        if (!fm.moveFound && !certainClearFound && !pe.isBestGuessOffEdge() && pe.getSolutionCount().compareTo(BigInteger.valueOf(preferences.getRolloutSolutions())) < 0) {

            this.logger.log(Logger.Level.INFO, "Doing adversarial rollout");

            long nanoStart = System.nanoTime();
            WitnessWeb arWholeEdge = new WitnessWeb(boardState, allWitnesses, allWitnessedSquares.getLocations());

            RolloutGenerator rolloutGenerator = new RolloutGenerator(boardState, arWholeEdge, unrevealed, minesLeft);
            rolloutGenerator.process();

            List<RolloutGenerator.Adversarial<CandidateLocation>> rolloutResult = rolloutGenerator.adversarial(bestCandidates);

            fm = new FinalMoves(rolloutResult.get(0).original.buildAction(MoveMethod.ROLLOUT));

            long nanoEnd = System.nanoTime();

            this.logger.log(Logger.Level.INFO, "Adversarial rollout took %f milli seconds", + (nanoEnd - nanoStart) / 1000000 );

        }

        // if we haven't got a move from the BFDA
        if (!fm.moveFound) {

            // no certain moves and we aren't doing tiebreaks
            if (!certainClearFound && !preferences.isDoTiebreak()) {

                // if off edge is better than on edge
                if (pe.isBestGuessOffEdge()) {
                    fm = guess(wholeEdge);
                } else {
                    // take the first move
                    for (CandidateLocation cl: bestCandidates) {
                        Action move = cl.buildAction(MoveMethod.PROBABILITY_ENGINE);
                        // let the boardState decide what to do with this action
                        boardState.setAction(move);
                        break;
                    }
                    Action[] moves = boardState.getActions().toArray(new Action[0]);
                    fm = new FinalMoves(moves);
                }
                return fm;
            } else if (addOffEdgeOptions && !certainClearFound) { // evaluate the off edge moves
                this.logger.log(Logger.Level.INFO, "Adding the off edge super locations to the candidate moves");

                if (allUnrevealedSquares == null) {   // defer this until we need it, can be expensive
                    allUnrevealedSquares = boardState.getAllUnrevealedSquares();
                }

                this.logger.log(Logger.Level.DEBUG, "About to evaluate best candidates -->");
                evaluateLocations.evaluateLocations(bestCandidates);

                evaluateLocations.evaluateOffEdgeCandidates(allUnrevealedSquares);

                this.logger.log(Logger.Level.DEBUG, "<-- Done");

                evaluateLocations.showResults();

                Action[] moves = evaluateLocations.bestMove();
                fm = new FinalMoves(moves);

            } else if (bestCandidates.size() == 1 || certainClearFound ) { // if there is only one solution or the solutions are certainties

                // register all the moves
                for (CandidateLocation cl: bestCandidates) {
                    Action move = cl.buildAction(MoveMethod.PROBABILITY_ENGINE);
                    // let the boardState decide what to do with this action
                    boardState.setAction(move);

                }

                // if we have a certain clear then also register all the mines
                if (certainClearFound) {
                    this.logger.log(Logger.Level.INFO, "Found %d mines using the probability engine", pe.getMines().size());
                    for (Location loc: pe.getMines()) {
                        // let the boardState decide what to do with this action
                        boardState.setAction(new Action(loc, Action.FLAG, MoveMethod.PROBABILITY_ENGINE, "",  BigDecimal.ONE));
                    }

                }

                if (playChords) {
                    EfficiencyHelper eff = new EfficiencyHelper(boardState, wholeEdge, boardState.getActions());
                    fm = new FinalMoves(eff.process().toArray(new Action[0]));
                } else {
                    fm = new FinalMoves(boardState.getActions().toArray(new Action[0]));
                }


            } else {    // evaluate which of the best candidates to choose
                this.logger.log(Logger.Level.DEBUG, "About to evaluate best candidates -->");
                evaluateLocations.evaluateLocations(bestCandidates);
                this.logger.log(Logger.Level.DEBUG, "<-- Done");

                evaluateLocations.showResults();

                Action[] moves = evaluateLocations.bestMove();
                fm = new FinalMoves(moves);

            }

            // if still no move then guess
            if (!fm.moveFound) {
                newLine("No certain, or high probability moves found, guess away from a witness");
                fm = guess(wholeEdge);
            }
        }


        return fm;
    }

    protected FinalMoves guess(WitnessWeb wholeEdge) {
        Action action = null;

        this.logger.log(Logger.Level.INFO, "Picking a guess");

        // get the starting move if we are at the start of the game
        if (myGame.getGameState() == GameStateModel.NOT_STARTED && playOpening) {
            if (overriddenStartLocation != null) {
                action = new Action(overriddenStartLocation, Action.CLEAR, MoveMethod.BOOK, "", offEdgeProb);
            } else {
                action = new Action(myGame.getStartLocation(), Action.CLEAR, MoveMethod.BOOK, "", offEdgeProb);
            }
        }


        // if there is no book move then look for a guess off the edge
        if (action == null) {
            List<CandidateLocation> list = new ArrayList<>();


            for (int i=0; i < myGame.getWidth(); i++) {
                for (int j=0; j < myGame.getHeight(); j++) {
                    // if we are an unrevealed square and we aren't on the contour
                    // then store the location
                    if (boardState.isUnrevealed(i,j)) {
                        Location l = new Location(i, j);
                        // if we aren't on the edge and there are some adjacent squares
                        if ((wholeEdge == null || !wholeEdge.isOnWeb(l))) {
                            list.add(new CandidateLocation(l.x, l.y, offEdgeProb, boardState.countAdjacentUnrevealed(l), boardState.countAdjacentConfirmedFlags(l)));
                        }

                    }
                }
            }

            // sort into most favourable order
            //Collections.sort(list, CandidateLocation.SORT_BY_PROB_FLAG_FREE);
            Collections.sort(list, CandidateLocation.SORT_BY_PROB_FREE_FLAG);

            // ... and pick the first one
            action = list.get(0).buildAction(MoveMethod.GUESS);
        }

        // this will check there isn't a flag blocking the move
        boardState.setAction(action);

        return new FinalMoves(boardState.getActions().toArray(new Action[0]));
    }

    private int findTrivialActions(List<? extends Location> witnesses) {

        int count = 0;

        for (Location loc: witnesses) {

            if (isObviousClear(loc)) {
                //boolean accepted = boardState.setChordLocation(loc);

                for (Location l: boardState.getAdjacentSquaresIterable(loc)) {
                    if (boardState.isUnrevealed(l)) {
                        if (!boardState.alreadyActioned(l)) {
                            count++;
                            boardState.setAction(new Action(l, Action.CLEAR, MoveMethod.TRIVIAL, "", BigDecimal.ONE));

                        }

                    }
                }

            } else if (isObviousFlag(loc)) {
                for (Location l: boardState.getAdjacentSquaresIterable(loc)) {
                    if (boardState.isUnrevealed(l)) {
                        if (!boardState.alreadyActioned(l)) {
                            count++;

                            boardState.setAction(new Action(l, Action.FLAG, MoveMethod.TRIVIAL, "",  BigDecimal.ONE));
                            //boardState.setFlagConfirmed(l);
                        }

                    }
                }
            }
        }
        return count;
    }

    private boolean isObviousClear(Location loc) {

        //if (boardState.isRevealed(x,y) && boardState.getWitnessValue(x,y) != 0) {
        int flags = boardState.countAdjacentConfirmedFlags(loc);

        // if we have all the flags and there is something to clear
        if (boardState.getWitnessValue(loc) == flags && boardState.countAdjacentUnrevealed(loc) > 0) {
            return true;
        }
        //}

        return false;

    }


    private boolean isObviousFlag(Location loc) {

        //if (boardState.isRevealed(x,y) && boardState.getWitnessValue(x,y) != 0) {
        int flags = boardState.countAdjacentConfirmedFlags(loc);
        int free = boardState.countAdjacentUnrevealed(loc);

        // if we only have space for the flags and there is some space
        if (boardState.getWitnessValue(loc) == flags + free && free > 0) {
            return true;
        }
        //}

        return false;

    }

    private int findLocalActions(List<? extends Location> witnesses) {

        int count = 0;

        List<Location> square;
        List<Location> witness;

        for (Location loc: witnesses) {

            int flags = boardState.countAdjacentConfirmedFlags(loc);
            int free = boardState.countAdjacentUnrevealed(loc);

            // if there are still some flags to find and there are
            // too many places for it to be obvious ...
            if (free > 0 && boardState.getWitnessValue(loc) > flags && boardState.getWitnessValue(loc) < flags + free) {

                // get the un-revealed squares
                square = boardState.getAdjacentUnrevealedSquares(loc);

                // now get the witnesses
                witness = boardState.getWitnesses(square);

                // and crunch the result
                if (witness.size() > 1) {

                    CrunchResult output = crunch(square, witness, new SequentialIterator(boardState.getWitnessValue(loc) - flags, square.size()), false, null);
                    count = count + checkBigTally(output, MoveMethod.LOCAL, "");
                    count = count + checkWitnesses(output, MoveMethod.LOCAL, "");

                }

            }


        }

        return count;

    }

    // do the tally check using the BigInteger values
    private int checkBigTally(CrunchResult output, MoveMethod method, String comment) {

        int result=0;

        // if there were no good candidates then there is nothing to check
        if (output.bigGoodCandidates.signum() == 0) {
            return 0;
        }

        // check the tally information to see if we have a square where a
        // mine is always present or never present
        for (int i=0; i < output.bigTally.length; i++) {

            if (output.bigTally[i].compareTo(output.bigGoodCandidates) == 0) {
                Location l = output.getSquare().get(i);

                if (!boardState.alreadyActioned(l)) {
                    result++;

                    boardState.setAction(new Action(l, Action.FLAG, method, comment, BigDecimal.ONE));

                }

            } else if (output.bigTally[i].signum() == 0) {
                Location l = output.getSquare().get(i);
                if (!boardState.alreadyActioned(l)) {
                    result++;

                    boardState.setAction(new Action(l, Action.CLEAR, method, comment, BigDecimal.ONE));
                    //display("clear found at " + x + " " + y);
                }
            }

        }

        return result;

    }


    // in some cases we learn more about the other witnesses during the crunch
    // this only happens for local search.
    private int checkWitnesses(CrunchResult output, MoveMethod method, String comment) {

        int result = 0;

        // check the witnesses to see if they have discovered something
        for (int i=0; i < output.witnessRestFlags.length; i++) {
            if (output.witnessGood[i] != 0) {
                if (output.witnessRestFlags[i]) {
                    //display("**** CheckWitnesses has found a FLAG " + output.witness[i].display());
                    result = result + restKnown(output.witness[i], output.getSquare(), Action.FLAG, method, comment);
                }
                if (output.witnessRestClear[i]) {
                    //display("**** CheckWitnesses has found a CLEAR " + output.witness[i].display());
                    result = result + restKnown(output.witness[i], output.getSquare(), Action.CLEAR, method, comment);
                }
            }
        }

        return result;

    }



    private int restKnown(Location witness, List<? extends Location> square, int action, MoveMethod method, String comment) {

        int result=0;

        for (Location l: boardState.getAdjacentSquaresIterable(witness)) {

            // find all the unflagged and unrevealed squares
            if (!boardState.isRevealed(l) && !boardState.isConfirmedFlag(l)) {

                //Location t = new Location(x1, y1);

                boolean found = false;
                for (Location k: square) {
                    if (l.equals(k)) {
                        found = true;
                        break;
                    }
                }

                if (!found && !boardState.alreadyActioned(l)) {

                    Action act;
                    if (action == Action.FLAG) {
                        act = new Action(l, Action.FLAG, method, comment, BigDecimal.ONE);
                        //boardState.setFlagConfirmed(act);
                    } else {
                        act = new Action(l, Action.CLEAR, method, comment, BigDecimal.ONE);
                    }
                    result++;

                    boardState.setAction(act);
                    //display("Discovered witness information at " + x1 + " " + y1);
                }

            }

        }


        return result;

    }

    @Override
    protected CrunchResult crunch(final List<Location> square, final List<? extends Location> witness, Iterator iterator, boolean calculateDistribution, BruteForceAnalysisModel bfa) {

        this.logger.log(Logger.Level.DEBUG, "Crunching %d Mines in %d Tiles with %d Witnesses", iterator.getBalls(), square.size(), witness.size());

        // the distribution is the number of times a square reveals as the number 0-8
        BigInteger[][] bigDistribution = null;
        if (calculateDistribution) {
            bigDistribution = new BigInteger[square.size()][9];
            for (int i=0; i < square.size(); i++) {
                for (int j=0; j < 9; j++) {
                    bigDistribution[i][j] = BigInteger.ZERO;
                }
            }
        }

        BigInteger bign = BigInteger.ZERO;


        // determine the witness type
        int[] witnessGood1 = generateWitnessType(witness, square);

        // encapsulate the witness data
        final WitnessData[] witnessData = new WitnessData[witness.size()];
        for (int i=0; i < witness.size(); i++) {
            WitnessData d = new WitnessData();
            d.location = witness.get(i);
            d.witnessGood = witnessGood1[i];
            d.witnessRestClear = true;
            d.witnessRestFlag = true;
            d.currentFlags = boardState.countAdjacentConfirmedFlags(d.location);
            d.alwaysSatisfied = iterator.witnessAlwaysSatisfied(d.location);
            witnessData[i] = d;
        }

        /*
        for (int i=0; i < square.length; i++) {
            display("Square " + i + " is " + square[i].display());
        }
        */

        int[] sample = iterator.getSample();

        int[] tally = new int[square.size()];
        int candidates = 0;

        // define work areas
        workRestNotFlags = new boolean[witnessData.length];
        workRestNotClear = new boolean[witnessData.length];

        while (sample != null) {

            if (checkSample(sample, square, witnessData, bigDistribution, bfa)) {
                for (int i=0; i < sample.length; i++) {
                    tally[sample[i]]++;
                }
                candidates++;
            }

            sample = iterator.getSample();

        }

        BigInteger[] bigTally = new BigInteger[square.size()];
        for (int i = 0; i < bigTally.length; i++) {
            bigTally[i] = BigInteger.valueOf(tally[i]);
        }

        bign = BigInteger.valueOf(candidates);

        // store all the information we have gathered into this object for
        // later analysis
        CrunchResult output = new CrunchResult();
        output.setSquare(square);
        output.bigDistribution = bigDistribution;

        output.originalNumMines = iterator.getBalls();
        output.bigGoodCandidates = bign;
        output.bigTally = bigTally;

        // return data on the witnesses
        output.witness = new Location[witnessData.length];
        output.witnessGood = new int[witnessData.length];
        output.witnessRestClear = new boolean[witnessData.length];
        output.witnessRestFlags = new boolean[witnessData.length];

        for (int i=0; i < witnessData.length; i++) {
            output.witness[i] = witnessData[i].location;
            output.witnessGood[i] = witnessData[i].witnessGood;
            output.witnessRestClear[i] = witnessData[i].witnessRestClear;
            output.witnessRestFlags[i] = witnessData[i].witnessRestFlag;
        }

        return output;

    }

    @Override
    // this checks whether the positions of the mines are a valid candidate solution
    protected boolean checkSample(final int[] sample, final List<Location> square, WitnessData[] witnessData, BigInteger[][] bigDistribution, BruteForceAnalysisModel bfa) {

        /*
        String s= "";
        for (int i = 0; i < sample.length; i++) {
            s = s + " " + sample[i];
        }
        display(s);
        */

        for (int i = 0; i < witnessData.length; i++) {
            workRestNotFlags[i] = false;
            workRestNotClear[i] = false;
        }


        // get the location of the mines
        Location[] mine = new Location[sample.length];
        for (int i = 0; i < sample.length; i++) {
            mine[i] = square.get(sample[i]);
        }

        for (int i = 0; i < witnessData.length; i++) {

            if (!witnessData[i].alwaysSatisfied) {
                int flags1 = witnessData[i].currentFlags;
                int flags2 = 0;

                // count how many candidate mines are next to this witness
                for (int j = 0; j < mine.length; j++) {
                    if (mine[j].isAdjacent(witnessData[i].location)) {
                        flags2++;
                    }
                }

                int flags3 = boardState.getWitnessValue(witnessData[i].location);

                // if the candidate solution puts more flags around the witness
                // than it says it has then the solution is invalid
                if (flags3 < flags1 + flags2) {
                    WitnessData d = witnessData[0];
                    witnessData[0] = witnessData[i];
                    witnessData[i] = d;
                    return false;
                }

                // if this is a 'good' witness and the number of flags around it
                // does not match with it exactly then the solution is invalid
                if (witnessData[i].witnessGood == 0 && flags3 != flags1 + flags2) {
                    WitnessData d = witnessData[0];
                    witnessData[0] = witnessData[i];
                    witnessData[i] = d;
                    return false;
                }

                if (flags3 != flags1 + flags2) {
                    workRestNotClear[i] = true;
                }
                if (flags3 != flags1 + flags2 + witnessData[i].witnessGood) {
                    workRestNotFlags[i] = true;
                }
            } else {
                // always satisfied means flag3 = flag1 + flag2, so the checks above can be simplified to
                if (witnessData[i].witnessGood != 0) {
                    workRestNotFlags[i] = true;
                }
            }

        }
        // if it is a good candidate solution then the witness information is valid
        for (int i = 0; i < witnessData.length; i++) {
            if (workRestNotClear[i]) {
                witnessData[i].witnessRestClear = false;
            }
            if (workRestNotFlags[i]) {
                witnessData[i].witnessRestFlag = false;
            }
        }

        //if it is a good solution then calculate the distribution if required
        if (bfa != null && !bfa.tooMany()) {
            byte[] solution = new byte[square.size()];

            for (int i = 0; i < square.size(); i++) {

                boolean isMine = false;
                for (int j = 0; j < sample.length; j++) {
                    if (i == sample[j]) {
                        isMine = true;
                        break;
                    }
                }

                // if we are a mine then it doesn't matter how many mines surround us
                if (!isMine) {
                    byte flags2 = (byte) boardState.countAdjacentConfirmedFlags(square.get(i));
                    // count how many candidate mines are next to this square
                    for (Location mine1 : mine) {
                        if (mine1.isAdjacent(square.get(i))) {
                            flags2++;
                        }
                    }
                    solution[i] = flags2;
                    if (bigDistribution != null) {
                        bigDistribution[i][flags2] = bigDistribution[i][flags2].add(BigInteger.ONE);
                    }

                } else {
                    solution[i] = GameStateModel.MINE;
                }

            }
            bfa.addSolution(solution);
        }

        return true;
    }

    @Override
    protected SolutionCounter validatePosition(WitnessWeb wholeEdge, List<Location> mines, List<Location> noMines, Area deadLocations) {

        // add the mines
        for (Location mine: mines) {
            boardState.setFlagConfirmed(mine);
        }

        Area witnessed = boardState.getUnrevealedArea(wholeEdge.getPrunedWitnesses());

        WitnessWeb edge = new WitnessWeb(boardState, wholeEdge.getPrunedWitnesses(), witnessed.getLocations(), Logger.NO_LOGGING);

        int unrevealed = boardState.getTotalUnrevealedCount() - mines.size();  // this is less, because we have added some mines

        int minesLeft = myGame.getMines() - boardState.getConfirmedFlagCount();

        SolutionCounter counter = new SolutionCounter(boardState, edge, unrevealed, minesLeft);

        // add the no mines
        if (noMines != null) {
            for (Location noMine: noMines) {
                counter.setMustBeEmpty(noMine);
            }
        }


        counter.process(deadLocations);

        // remove the mines
        for (Location mine: mines) {
            boardState.unsetFlagConfirmed(mine);
        }

        return counter;

    }

    @Override
    protected RunPeResult runProbabilityEngine(WitnessWeb wholeEdge, Location location, int value) {

        // make the move
        boardState.setWitnessValue(location, value);

        // create a new list of witnesses
        List<Location> witnesses = new ArrayList<>(wholeEdge.getPrunedWitnesses().size() + 1);
        witnesses.addAll(wholeEdge.getPrunedWitnesses());
        witnesses.add(location);

        Area witnessed = boardState.getUnrevealedArea(witnesses);

        WitnessWeb edge = new WitnessWeb(boardState, witnesses, witnessed.getLocations(), Logger.NO_LOGGING);

        int unrevealed = boardState.getTotalUnrevealedCount() - 1;  // this is one less, because we have added a witness

        int minesLeft = myGame.getMines() - boardState.getConfirmedFlagCount();

        RunPeResult result = new RunPeResult();
        result.pe = new ProbabilityEngineFast(boardState, edge, unrevealed, minesLeft);

        result.pe.process();

        // looking for created 50/50s doesn't seem to help the win rate
    	 /*
    	 Location findFifty = new FiftyFiftyHelper(boardState, wholeEdge, deadLocations).findUnavoidable5050(result.pe.getMines());

    	 if (findFifty != null) {
    		 //this.logger.log(Level.WARN, "Fifty/Fifty created in game %s : %s", myGame.showGameKey(), findFifty );
    		 result.found5050 = true;
    	 }
		 */

        // undo the move
        boardState.clearWitness(location);

        return result;

    }

}
